<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //         手写源生 CSS
      // 使用预处理器 Sass/Less
      // 使用后处理器 PostCSS
      // 使用 css modules
      // 使用 css in js

      //       行内样式，即直接在 html 中的 style 属性里编写 css 代码。
      // 内嵌样式，即在 html h 中的 style 标签内编写 class，提供给当前页面使用。
      // 导入样式，即在内联样式中 通过 @import 方法，导入其他样式，提供给当前页面使用。
      // 外部样式，即使用 html 中的 link 标签，加载样式，提供给当前页面使用。

      // 我们在不断摸索中，逐渐形成了以编写内嵌样式和外部样式为主要的编写习惯。

      // 使用行内样式的缺点

      // 样式不能复用。
      // 样式权重太高，样式不好覆盖。
      // 表现层与结构层没有分离。
      // 不能进行缓存，影响加载效率。

      // 在 IE6-8 下，@import 声明指向的样式表并不会与页面其他资源并发加载，而是等页面所有资源加载完成后才开始下载。
      // 如果在 link 标签中去 @import 其他 css，页面会等到所有资源加载完成后，才开始解析 link 标签中 @import 的 css。

      //       导入样式，只能放在 style 标签的第一行，放其他行则会无效。
      // @import 声明的样式表不能充分利用浏览器并发请求资源的行为，其加载行为往往会延后触发或被其他资源加载挂起。
      // 由于 @import 样式表的延后加载，可能会导致页面样式闪烁。

      //   预处理器主要是强化了 css 的语法，弥补了上文说了这些问题，但本质上，打包出来的结果和源生的 css 都是一样的，只是对开发者友好，写起来更顺滑。

      //     postcss 可以称作为 css 界的 babel，它的实现原理是通过 ast 去分析我们的 css 代码，然后将分析的结果进行处理，从而衍生出了许多种处理 css 的使用场景。

      //     配合 stylelint 校验 css 语法
      // 自动增加浏览器前缀 autoprefixer
      // 编译 css next 的语法

      //       css 是根据类名去匹配元素的，如果有两个组件使用了一个相同的类名，后者就会把前者的样式给覆盖掉，看来解决样式命名的冲突是个大问题。

      // 为了解决这个问题，产生出了 CSS 模块化的概念。

      //   CSS Modules 不能直接使用，而是需要进行打包，一般通过配置 css-loader 中的 modules 属性即可完成 css modules 的配置。

      // webpack.config.js
      // module.exports = {
      //   module: {
      //     rules: [
      //       {
      //         test: /\.css$/,
      //         use:{
      //           loader: 'css-loader',
      //           options: {
      //             modules: {
      //               // 自定义 hash 名称
      //               localIdentName: '[path][name]__[local]--[hash:base64:5]',
      //             }
      //           }
      //        }
      //     ]
      //   }
      // };

    //   css模块化   主要目的提供css作用域，避免全局样式冲突
    </script>
  </body>
</html>
